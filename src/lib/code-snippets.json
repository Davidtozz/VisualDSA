{
  "Algorithms": {
    "sorts": {
      "bubblesort": {
        "description": "Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.",
        "code": {
          "JavaScript": "function bubbleSort(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        for (let j = 0; j < arr.length - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n}",
          "TypeScript": "function bubbleSort(arr: number[]) {\n    for (let i = 0; i < arr.length; i++) {\n        for (let j = 0; j < arr.length - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n}",
          "Java": "public class BubbleSort {\n    public static void bubbleSort(int[] arr) {\n        for(int i = 0; i < arr.length; i++) {\n            for(int j = 0; j < arr.length - i - 1; j++) {\n            if(arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}",
          "C": "#include <stdio.h>\n\nvoid swap(int* arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nvoid bubbleSort(int arr[], int n) {\n    int i, j;\n    for (i = 0; i < n - 1; i++) {\n        for (j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1])\n                swap(arr, j, j + 1);\n        }\n    }\n}",
          "C++": "using namespace std;\n\nvoid swap(int* xp, int* yp) {\n    int temp = *xp;\n    *xp = *yp;\n    *yp = temp;\n}\n\nvoid bubbleSort(int arr[], int n) {\n    int i, j;\n    for (i = 0; i < n - 1; i++) {\n        for (j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n            }\n        }\n    }\n}"
        }
      },
      "insertionsort": {
        "description": "Insertion sort is a simple sorting algorithm that works by iteratively inserting each element of an unsorted list into its correct position in a sorted portion of the list.",
        "code": {
          "TypeScript": "function insertionSort(arr: number[]) {\n    let i, key, j;\n    for (i = 1; i < arr.length; i++) {\n        key = arr[i];\n        j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}",
          "JavaScript": "function insertionSort(arr) {\n    let i, key, j;\n    for (i = 1; i < arr.length; i++) {\n        key = arr[i];\n        j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}   ",
          "Java": "public class InsertionSort {\n    public static void insertionSort(int[] arr) {\n        int i, key, j;\n        for (i = 1; i < arr.length; i++) {\n            key = arr[i];\n            j = i - 1;\n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j = j - 1;\n            }\n            arr[j + 1] = key;\n        }\n    }   \n}",
          "C": "void insertionSort(int arr[]) {\n    \n    int arrlength = sizeof(arr) / sizeof(arr[0]);\n    \n    for (int i = 1; i < arrlength; ++i) {\n        int key = arr[i];\n        int j = i - 1;\n\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n\n        arr[j + 1] = key;\n    }\n}",
          "C++": "using namespace std;\n\nvoid insertionSort(int arr[]) {\n\n    int arrlength = sizeof(arr) / sizeof(arr[0]);\n\n    for (int i = 1; i < arrlength; ++i) {\n        int key = arr[i];\n        int j = i - 1;\n\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n\n        arr[j + 1] = key;\n    }\n}"
        }
      },
      "quicksort": {
        "description": "Quick sort is a comparison sort, meaning that it can sort items of any type for which a \"less-than\" relation is defined.",
        "code": {
          "JavaScript": "function quickSort(arr) {\n  if (arr.length <= 1) {\n    return arr;\n  }\n  let pivot = arr[0];\n  let left = [];\n  let right = [];\n  for (let i = 1; i < arr.length; i++) {\n    arr[i] < pivot ? left.push(arr[i]) : right.push(arr[i]);\n  }\n  return quickSort(left).concat(pivot, quickSort(right));\n}",
          "TypeScript": "function quickSort(arr: number[]): number[] {\n  if (arr.length <= 1) {\n    return arr;\n  }\n  let pivot = arr[0];\n  let left: number[] = [];\n  let right: number[] = [];\n  for (let i = 1; i < arr.length; i++) {\n    arr[i] < pivot ? left.push(arr[i]) : right.push(arr[i]);\n  }\n  return quickSort(left).concat(pivot, quickSort(right));\n}",
          "Java": "public static void quickSort(int[] arr, int low, int high) {\n  if (low < high) {\n    int pi = partition(arr, low, high);\n    quickSort(arr, low, pi - 1);\n    quickSort(arr, pi + 1, high);\n  }\n}\n\npublic static int partition(int[] arr, int low, int high) {\n  int pivot = arr[high];\n  int i = low - 1;\n  for (int j = low; j < high; j++) {\n    if (arr[j] < pivot) {\n      i++;\n      int temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n    }\n  }\n  int temp = arr[i + 1];\n  arr[i + 1] = arr[high];\n  arr[high] = temp;\n  return i + 1;\n}",
          "C++": "void quickSort(int arr[], int low, int high) {\n  if (low < high) {\n    int pi = partition(arr, low, high);\n    quickSort(arr, low, pi - 1);\n    quickSort(arr, pi + 1, high);\n  }\n}\n\nint partition(int arr[], int low, int high) {\n  int pivot = arr[high];\n  int i = low - 1;\n  for (int j = low; j < high; j++) {\n    if (arr[j] < pivot) {\n      i++;\n      swap(arr[i], arr[j]);\n    }\n  }\n  swap(arr[i + 1], arr[high]);\n  return i + 1;\n}",
          "C": "void quickSort(int arr[], int low, int high) {\n  if (low < high) {\n    int pi = partition(arr, low, high);\n    quickSort(arr, low, pi - 1);\n    quickSort(arr, pi + 1, high);\n  }\n}\n\nint partition(int arr[], int low, int high) {\n  int pivot = arr[high];\n  int i = low - 1;\n  for (int j = low; j < high; j++) {\n    if (arr[j] < pivot) {\n      i++;\n      int temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n    }\n  }\n  int temp = arr[i + 1];\n  arr[i + 1] = arr[high];\n  arr[high] = temp;\n  return i + 1;\n}"
        }
      },
      "selectionsort": {
        "description": "Selection sort is an in-place comparison sorting algorithm that divides the input list into two parts: the sublist of items already sorted and the sublist of items remaining to be sorted.",
        "code": {
          "TypeScript": "function selectionSort(arr: number[]) {\n    let n = arr.length;\n    for (let i = 0; i < n - 1; i++) {\n        let min_index = i;\n        for (let j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_index]) {\n                min_index = j;\n            }\n        }\n        // swap\n        const temp = arr[min_index];\n        arr[min_index] = arr[i];\n        arr[i] = temp;\n    }\n}",
          "JavaScript": "function selectionSort(arr) {\n    let n = arr.length;\n    for (let i = 0; i < n - 1; i++) {\n        let min_index = i;\n        for (let j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_index]) {\n                min_index = j;\n            }\n        }\n        // swap\n        const temp = arr[min_index];\n        arr[min_index] = arr[i];\n        arr[i] = temp;\n    }\n}",
          "Java": "public SelectionSort {\n    public static void selectionSort(int[] arr) {\n        int n = arr.length;\n        for (let i = 0; i < n - 1; i++) {\n            int min_index = i;\n            for (let j = i + 1; j < n; j++) {\n                if (arr[j] < arr[min_index]) {\n                    min_index = j;\n                }\n            }\n            // swap\n            int temp = arr[min_index];\n            arr[min_index] = arr[i];\n            arr[i] = temp;\n        }\n    }\n}",
          "C": "void swap(int *xp, int *yp)\n{\n    int temp = *xp;\n    *xp = *yp;\n    *yp = temp;\n}\n\nvoid selectionSort(int arr[]) {\n        int arrlength = sizeof(arr) / sizeof(arr[0]);\n        for (int i = 0; i < arrlength - 1; i++) {\n            let min_index = i;\n            for (int j = i + 1; j < arrlength; j++) {\n                if (arr[j] < arr[min_index]) {\n                    min_index = j;\n                }\n            }\n            // swap\n            if(min_index != i) \n                swap( & arr[min_index],&arr[i]);\n            }\n        }\n    }\n}",
          "C++": "using namespace std;\n\nvoid swap(int *xp, int *yp)\n{\n    int temp = *xp;\n    *xp = *yp;\n    *yp = temp;\n}\n\nvoid selectionSort(int arr[]) {\n        int arrlength = sizeof(arr) / sizeof(arr[0]);\n        for (int i = 0; i < arrlength - 1; i++) {\n            let min_index = i;\n            for (int j = i + 1; j < arrlength; j++) {\n                if (arr[j] < arr[min_index]) {\n                    min_index = j;\n                }\n            }\n            // swap\n            if(min_index != i)\n                swap( & arr[min_index],&arr[i]);\n            }\n        }\n    }\n}"
        }
      },
      "shellsort": {
        "description": "Shell sort is a highly efficient sorting algorithm and is based on insertion sort algorithm. This algorithm avoids large shifts as in case of insertion sort, if the smaller value is to the far right and has to be moved to the far left.",
        "code": {
          "TypeScript": "function shellSort(arr: number[]) {\n    let interval = 1;\n    \n    while (interval < arr.length / 3) {\n        interval = interval * 3 + 1;\n    }\n\n    while (interval > 0) {\n        for (let outer = interval; outer < arr.length; outer++) {\n            const value = arr[outer];\n            let inner = outer;\n\n            while (inner > interval - 1 && arr[inner - interval] >= value) {\n                arr[inner] = arr[inner - interval];\n                inner -= interval;\n            }\n\n            arr[inner] = value;\n        }\n        interval = (interval - 1) / 3;\n    }\n}",
          "JavaScript": "function shellSort(arr) {\n    let interval = 1;\n    arr.length;\n\n    while (interval < arr.length / 3) {\n        interval = interval * 3 + 1;\n    }\n\n    while (interval > 0) {\n        for (let outer = interval; outer < arr.length; outer++) {\n            const value = arr[outer];\n            let inner = outer;\n\n            while (inner > interval - 1 && arr[inner - interval] >= value) {\n                arr[inner] = arr[inner - interval];\n                inner -= interval;\n            }\n\n            arr[inner] = value;\n        }\n        interval = (interval - 1) / 3;\n    }\n}",
          "Java": "public class ShellSort {\n    public static void shellSort(int[] arr) {\n        int interval = 1;\n        \n        while (interval < arr.length / 3) {\n            interval = interval * 3 + 1;\n        }\n\n        while (interval > 0) {\n            for (let outer = interval; outer < arr.length; outer++) {\n                int value = arr[outer];\n                int inner = outer;\n\n                while (inner > interval - 1 && arr[inner - interval] >= value) {\n                    arr[inner] = arr[inner - interval];\n                    inner -= interval;\n                }\n\n                arr[inner] = value;\n            }\n            interval = (interval - 1) / 3;\n        }\n    }\n}",
          "C": "#include <stdio.h>\n\nvoid shellSort(int array[], int n) {\n    for (int interval = n / 2; interval > 0; interval /= 2) {\n        for (int i = interval; i < n; i += 1) {\n            int temp = array[i];\n            int j;\n            for (j = i; j >= interval && array[j - interval] > temp; j -= interval) {\n                array[j] = array[j - interval];\n            }\n            array[j] = temp;\n        }\n    }\n}",
          "C++": "#include <iostream>\nusing namespace std;\n\n// Shell sort\nvoid shellSort(int array[], int n) {\n    for (int interval = n / 2; interval > 0; interval /= 2) {\n        for (int i = interval; i < n; i += 1) {\n            int temp = array[i];\n            int j;\n            for (j = i; j >= interval && array[j - interval] > temp; j -= interval) {\n                array[j] = array[j - interval];\n            }\n            array[j] = temp;\n        }\n    }\n}"
        }
      }
    }
  },
  "DataStructures": {
    "linkedlist": {
      "displayName": "LinkedList",
      "isGeneric": true,
      "description": "A linear data structure whose elements' order is not given by their physical placement in memory.",
      "methods": [
        {
          "name": "append",
          "description": "Adds a new node to the end of the linked list.",
          "params": {
            "data": "The data to be stored in the new node."
          },
          "returnType": "void",
          "code": {
            "TypeScript": "    public append(data: T): void {\n        const newNode = new ListNode<T>(data, null);\n        if(this.head === null) {\n            this.head = newNode;\n        } else {\n            let current = this.head;\n            while(current.next !== null) {\n                current = current.next;\n            }\n            current.next = newNode;\n            this.length++;\n        }\n    }"
          }
        },
        {
          "name": "removeAt",
          "description": "Removes a node at a specific index.",
          "params": {
            "position": "The nth-position of the node in the list to be removed."
          },
          "returnType": "void",
          "code": {
            "TypeScript": "    public removeAt(position: number): void {\n        if (this.head === null) return;\n\n        if (position === 0) {\n            this.head = this.head.next;\n            return;\n        }\n        let current: ListNode<T> | null = this.head;\n        let previous: ListNode<T> | null = null;\n        let count = 0;\n\n        while (current !== null && count < position) {\n            previous = current;\n            current = current.next;\n            count++;\n        }\n        if (current === null) {\n            return;\n        }\n\n        if (previous) previous.next = current.next;\n    }"
          }
        }
      ],
      "fields": [
        {
          "name": "length",
          "type": {
            "JavaScript": "number",
            "TypeScript": "number",
            "Java": "int",
            "C": "int",
            "C++": "int"
          }
        },
        {
          "name": "head",
          "type": {
            "JavaScript": "ListNode",
            "TypeScript": "ListNode<T>",
            "Java": "ListNode<T>",
            "C": "ListNode",
            "C++": "ListNode"
          }
        }
      ],
      "dependencies": [
        {
          "name": "ListNode<T>",
          "description": "ListNode is a class that represents a single node in a linked list.",
          "fields": [
            {
              "name": "data",
              "type": {
                "JavaScript": "any",
                "TypeScript": "T",
                "Java": "T",
                "C": "void*",
                "C++": "T"
              }
            },
            {
              "name": "next",
              "type": {
                "JavaScript": "ListNode | null",
                "TypeScript": "ListNode<T> | null",
                "Java": "ListNode<T> | null",
                "C": "ListNode*",
                "C++": "ListNode*"
              }
            }
          ]
        }
      ]
    }
  }
}